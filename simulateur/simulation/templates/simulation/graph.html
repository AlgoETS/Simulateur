{% extends 'includes/base_generic.html' %}
{% block content %}
<div class="container mx-auto p-6">
    <h1 class="text-3xl font-bold mb-6">WebSocket Simulation Test</h1>
    <div class="mb-6 flex gap-4">
        <button id="startBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded">Start Simulation</button>
        <button id="pauseBtn" class="bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-6 rounded">Pause Simulation</button>
        <button id="stopBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-6 rounded">Stop Simulation</button>
    </div>
    <div class="mb-6">
        <label for="scenarioSelect" class="block text-gray-700 font-medium mb-2">Select Scenario:</label>
        <select id="scenarioSelect" class="bg-white shadow rounded p-2 border border-gray-300 w-full">
            {% for scenario in scenarios %}
                <option value="{{ scenario.id }}">{{ scenario.name }}</option>
            {% endfor %}
        </select>
    </div>
    <div id="charts" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
    <div id="messages" class="mt-6 space-y-4"></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.6/dist/lightweight-charts.standalone.production.min.js"></script>
<script>
    let socket;
    let charts = {};
    let data = {};

    async function fetchStocksForScenario() {
        const scenarioId = document.getElementById('scenarioSelect').value;
        const response = await fetch(`/api/scenarios/${scenarioId}/stocks/`);
        if (!response.ok) {
            console.error('Failed to fetch stocks:', response.statusText);
            return;
        }
        const stocks = await response.json();
        data = {};
        charts = {};
        document.getElementById('charts').innerHTML = '';
        if (!Array.isArray(stocks)) {
            console.error('Failed to fetch stocks: response is not an array.');
            return;
        }
        stocks.forEach(stock => {
            if (!data[stock.ticker]) {
                data[stock.ticker] = stock.price_history.map(price => ({
                    time: new Date(price.timestamp).getTime() / 1000,
                    open: price.open_price,
                    high: price.high_price,
                    low: price.low_price,
                    close: price.close_price
                }));
                createChartContainer(stock.ticker);
                initializeChart(stock.ticker);
            }
        });
    }

    function createChartContainer(stockTicker) {
        const chartsDiv = document.getElementById('charts');
        const container = document.createElement('div');
        container.className = 'chart-container bg-white shadow rounded-lg p-4 relative';
        const chartElement = document.createElement('div');
        chartElement.id = stockTicker.replace(/\s+/g, '-') + '-chart';
        container.appendChild(chartElement);
        chartsDiv.appendChild(container);
    }

    function initializeChart(stockTicker) {
        const chartElement = document.getElementById(stockTicker.replace(/\s+/g, '-') + '-chart');
        const chart = LightweightCharts.createChart(chartElement, {
            width: chartElement.clientWidth,
            height: chartElement.clientHeight,
            layout: {
                backgroundColor: '#ffffff',
                textColor: '#000000',
            },
            grid: {
                vertLines: {
                    color: '#e0e0e0',
                },
                horzLines: {
                    color: '#e0e0e0',
                },
            },
            priceScale: {
                borderColor: '#cccccc',
            },
            timeScale: {
                borderColor: '#cccccc',
                timeVisible: true,
                secondsVisible: false,
            },
        });

        const candlestickSeries = chart.addCandlestickSeries();
        candlestickSeries.setData(data[stockTicker]);
        charts[stockTicker] = chart;
    }

    async function startSimulation() {
        const scenarioId = document.getElementById('scenarioSelect').value;
        await fetchStocksForScenario();

        if (socket) {
            socket.close();
        }

        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const socket = new WebSocket(protocol + '//' + window.location.host + '/ws/simulation/stock/');

        socket.onopen = function () {
            console.log("WebSocket connection established");
            addMessage("WebSocket connection established", "green");
        };

        socket.onmessage = function (e) {
            console.log("Message received: " + e.data);
            const messageData = JSON.parse(e.data);
            if (validateMessage(messageData)) {
                updateChart(messageData);
            } else {
                console.warn("Received malformed message:", messageData);
            }
        };

        socket.onclose = function () {
            console.log("WebSocket connection closed");
            addMessage("WebSocket connection closed", "red");
        };

        socket.onerror = function (e) {
            console.log("WebSocket error: " + e.data);
            addMessage("WebSocket error: " + e.data, "red");
        };

        setInterval(() => {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ action: 'fetch_data' }));
            }
        }, 1000); // Adjust the interval as needed
    }

    function validateMessage(message) {
        const requiredFields = ['ticker', 'timestamp', 'open', 'high', 'low', 'close'];
        for (const field of requiredFields) {
            if (!message.hasOwnProperty(field)) {
                return false;
            }
        }
        return true;
    }

    function pauseSimulation() {
        if (socket) {
            socket.close();
            console.log('Simulation paused');
            addMessage("Simulation paused", "yellow");
        }
    }

    function stopSimulation() {
        if (socket) {
            socket.close();
            console.log('Simulation stopped');
            addMessage("Simulation stopped", "red");
        }
    }

    function updateChart(message) {
        const stockTicker = message.ticker;
        if (!charts[stockTicker]) {
            console.warn(`Chart for ${stockTicker} not found.`);
            return;
        }

        const ohlcData = {
            time: new Date(message.timestamp).getTime() / 1000,
            open: message.open,
            high: message.high,
            low: message.low,
            close: message.close
        };

        const chart = charts[stockTicker];
        const series = chart.series[0];
        series.update(ohlcData);
    }

    function addMessage(message, color) {
        const messageContainer = document.createElement('div');
        messageContainer.className = `bg-${color}-100 text-${color}-800 p-2 rounded shadow`;
        messageContainer.innerHTML = message;
        document.getElementById('messages').appendChild(messageContainer);
    }

    document.addEventListener("DOMContentLoaded", function() {
        document.getElementById('startBtn').addEventListener('click', startSimulation);
        document.getElementById('pauseBtn').addEventListener('click', pauseSimulation);
        document.getElementById('stopBtn').addEventListener('click', stopSimulation);
        fetchStocksForScenario();
    });

    window.onbeforeunload = function () {
        if (socket) {
            socket.close();
        }
    };
</script>
{% endblock %}
